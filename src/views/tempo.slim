ruby:
  ps = Async { JSON `docker ps --filter "label=com.docker.swarm.service.name=grafana_grafana" --format '{{.ID}}' | xargs -r docker inspect -s 2>&1 | jq -s ` }
  ps = ps.wait.first&.group_by { _1.dig 'Config', 'Labels', 'com.docker.swarm.task.id' }&.transform_values(&:first) || {}
  service_errors = Hash.new(0)

  con = ps.first.last
  if con
    #traces = `docker exec #{con['Id']} curl -G -s  http://tempo:3200/api/search --data-urlencode 'tags=service.name=#{params[:service]}' --data-urlencode 'q={ .deployment.environment = "map-back" }' --data-urlencode limit=100 2>&1`
    query = {
            q: %[{ resource.deployment.environment="#{params[:stack]}" && name=~".*" &&  status=error}],
            start: (Time.now - 30*60).to_i, end: Time.now.to_i, limit: 100, spss: 1
    }
    traces = `docker exec #{con['Id']} curl -G -s  http://tempo:3200/api/search  #{ query.map { |k,v| "--data-urlencode '#{k}=#{v}' " }.join ' ' } 2>&1`
    traces_ = JSON traces, symbolize_names: true rescue traces
    traces_[:traces]&.each do |t|
      t[:serviceStats]&.each do |name, s|
        if s[:errorCount].to_i > 0
          service_errors[name] += s[:errorCount]
        end
      end
    end
    service_errors
  end


h1 Service spans: #{params[:stack]}
pre#traces = JSON.pretty_generate(service_errors)
pre#traces = JSON.pretty_generate(traces_)
